> main :: IO ()
> main = do{
>    print "what's ur name ";
>    name <- getLine;
>    print $ "hello " ++ name
>}
> 

这是一个简单的helloworld程序，让我们运行一下

ghci> main
"hello world"

但是呢，我们肯定不能从这里开始学haskell，因为这里涉及到了一些看起来简单实际上比较深入的知识。

我们从定义简单的函数开始学起。

> --add :: Num a => a -> a -> a
> --add a b = a + b



> n1 = 114514

> s1 = "下北泽"

> l1 = [1,9,1,9,8,1,0]

相比于其他的语言，haskell多了什么？又少了什么？

多了什么：

更好的类型声明，类型约束

更自由的函数应用

模式匹配的函数定义

少了什么：

变量

顺序、分支、循环的控制结构

先看少了什么，变量。

现在看这样一行代码。

> a :: Int 
> a = 1

看上去这就是一个变量？

但是如果我接下来这样做

> -- a = 2

却是报错的。

因为这里的 a
它不是变量，它不能被改变，它甚至不是常量。

它是函数。

你可以这样认为，它是一个零元的函数。

然后是顺序分支循环的结构，haskell里是没有的。
一个haskell函数就是一个表达式。

所以就要提到在haskell里多了什么了。

分支可以被模式匹配在一定程度上代替，而循环也可以用map、filter、list comprehension来代替

比如定义一个取列表的第一个元素的函数

> f :: [a] ->Maybe  a
> f [] = Nothing 
> f (x:_) = Just x

> ff :: [a] -> a
> ff (x:_) = x

这里定义了两个f []和f (x:_)体现的就是模式匹配。在命令式语言中一般要用分支语句去实现这样的效果。

再说一下haskell中的类型声明，看下面的例子：

> add :: Num a => a -> a -> a
> add a b = a + b

这里的Num a表示a是一个类型，这个类型具体是什么不确定，能确定的是它是一个数值类型，他可能是Int，Float，Integer但这些类型都是Num类族的成员。

我们管 Num a这种叫做类型约束。

而后面的 a -> a -> a 

就是这个函数的具体类型了。

前面的两个a，表示函数接受的两个参数都是a类型的值。最后的一个a表示这个函数的返回值。

有人可能会问为什么要写成这种形式，而不是 (a,a)-> a这种更好懂得形式？

这就要涉及到haskell得柯里化的特性了。