# 柯里化

现在让我们来详细的聊一聊，haskell中这个奇怪的函数类型`a -> a -> a`为什么不是`(a,a) -> a`吧。

在这里用一小段javascript代码来演示一下，因为很简单，没学过js的同学也可以当作伪代码来看。

```javascript
// 这是一个柯里化的加法函数定义。
function add(x){
    function addX(y){
        return x + y;
    }
    return addX;
}

//这是一个非柯里化的加法定义。
function noCurry(x,y){
    return x + y;
}

console.log(add(1)(2));     //3
console.log(noCurry(1,2));  //3
```

从定义上看，柯里化的作用是使单参函数多参化。在大多数程序语言中表现为，在你定义的一个单参函数中，定义第二个单参函数，然后在第一个函数中将第二个函数作为返回值返回。

这样做的原因和好处分别是什么呢？

最根本的原因是，函数式程序设计的理论源头，lambda演算并不天然支持多参函数。

一个lambda函数大致长成这样

$$
λx.x
$$

其中x是参数，也是返回值。

如果希望使用多个参数，需要用到柯里化。

$$
λx.λy.x + y
$$

这里`x`是参数，`λy.x+y`是最外层函数的返回值，也是一个函数。而里面这个函数的参数是`y`，它的返回值是`x+y`

这样做的好处也很简单，那就是可以方便的完成上一章描述的函数组合、函数的部分应用、随时创造新的函数。

还记得我说过的吗？函数组合是函数式编程的核心，如果能舒服的完成函数组合，那么这种程序语言就是优秀的函数式程序语言了。

而在haskell中,为了方便使用，柯里化是默认支持的。

回到haskell函数中来。

```haskell
add :: a -> a -> a
add a b = a + b
```

当我们仅给add传递一个参数的时候，它实际上返回了一个函数。传递第二个参数，他才会返回预期的计算结果。

当然了，如果你不喜欢柯里化，在haskell中也是有办法的。可以这样写。

```haskell
add :: (a,a) -> a
add (x,y) = x+y
```

这样做的本质是将多个参数打包进一个**元组**中，一次性传递。这样做的话，haskell的部分应用特性就不能用了。 

下一篇文章将介绍haskell的lambda函数。