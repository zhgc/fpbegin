# lambda函数

让我们回到函数式编程的起源，lambda演算。在lambda演算中，一个函数就是一个表达式，而不是命令式编程的“过程”。虽然lambda表达式并非现代函数式程序设计必须的东西（还是那句话，一只鸟不需要了解空气动力学也能飞行），但所有的函数式程序语言都不约而同的实现了他们自己的lambda表达式。

以防有人没看过lambda演算那一章，先看一下典型的lambda演算定义的函数：

$$
λx.x
$$

逐个解释一下。`λ`表示定义一个λ函数。`x`表示这个函数的参数，这是一个抽象符号，可以代表任何东西。`.`表示后面的部分是函数的计算。最后的`x`是这个函数的计算过程，因为并没有用这个x做任何事，所以，这个函数将会返回它接受的任何参数。

接下来，试着在haskell中定义一个相同的函数。

```haskell
id :: a -> a
id = \x -> x
-- 为了方便理解，给这个lambda函数起个名字，实际使用的时候不需要起名。
```

接下来试着用lambda的方式定义一下前面的一些函数。

```haskell
-- 加法的lambda表达式定义
add :: a -> a -> a
add = \a b -> a + b

-- 柯里化的lambda定义。

addCurry :: a -> a -> a
addCurry = \a -> \b -> a + b
```

当然，这样做是令人费解的，毕竟haskell原生支持柯里化，所以这个`add` 和 `addCurry`似乎没有什么区别。是的，这样写只是为了在形式上方便读者了解，在柯里化的过程中，lambda究竟做了什么。

上一篇文章用js演示了柯里化，不妨再用js演示一下用lambda定义的柯里化吧。

```javascript
let addCurry = (x) => {
    let addX = (y) => {
        return x + y;
    } 
    return addX;
}
console.log(addCurry(1)(2));
```

看起来很不错，不过似乎和原先的版本差别不是很大，我相信javascript肯定还有更大的潜力，让我们试试下面的写法。

```javascript
let addCurry = (x) => (y) => x + y;
console.log(addCurry(2)(2));
```

这样是不是差距就非常明显了？所以说，掌握lambda表达式，在你对函数式编程十分熟悉之后，进行简化操作，是帮助非常大的。

顺便一提，本人对JavaScript其实了解不深，本系列涉及js的部分大多都是根据我对haskell的特性了解，去现搜了一点js语法之后现写出来的。

这足可以说明两件事，其一是你在haskell中学到的函数式程序设计知识，可以在其它语言中运用，第二点是JavaScript，本身对函数式特性的支持也相当不错。

在haskell中，lambda的使用方式也十分丰富，如果仔细看一下的话，就会发现haskell的图标正是一个λ。也正因为使用范围太广，在这里就不过度展开了。但在学到case of，高阶函数，组合子，递归类型的时候，我们还将再次接触到lambda。

下一篇文章将会介绍高阶函数。