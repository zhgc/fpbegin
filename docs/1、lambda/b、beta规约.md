# β规约
在学习更多的lambda函数之前，需要了解lambda演算中最重要的概念，β规约。

β规约定义的是我们进行**函数应用**的过程。

```
id = λx.x

-- 当我对id应用1时，就是将他的参数x替换成1

id 1 -- 等于1

-- 注意，lambda中以空格描述函数定义id 1就表示一般理解中的id(1)
```

但是当我用其他东西应用于id的时候

```
id = λx.x
succ = λx.x+1

id succ -- 等于succ
```

也就是说，参数可以被代换为各种东西，包括另一个函数。

他的过程大概是这样
```
id succ
= {将id替换成lambda式}
(λx.x) succ
= {将succ替换变量x}
(λsucc.succ)
= {在替换的过程完成之后，变量x就不存在了，而是全部由succ代替}
succ
= {将succ替换成lambda}
λx.x+1
```

# 更多函数

由于λ符号输入的有一点麻烦，后面我用`\`来代替`λ`。用`->`代替`.` 。也就是说`id = \x->x`

现在开始定义一些函数
```
true = \x y -> x

false = \x y -> y

0 = \f x -> x

1 = \f x -> f x
-- 是的，数字也是函数。别急，继续往下看。

succ = \n f x -> f (n f x)
-- 是的，之前定义的succ只是为了方便看懂，这里的才是完整版。他的功能实际上是获得一个自然数的后继数

pred = \n f x -> n (\g h -> h (g f)) (\u -> x) (\u -> u)
-- 这个函数和succ相对，获得自然数的前驱数。
```

众所周知，lambda演算是和图灵机等价的**通用计算模型**，但是在计算之前，必须先有数字。在lambda演算中，数字也是用函数表示的。（也就是说，一切都是函数）

关于自然数的定义，下一篇再讲，我们先直接看一下数是如何使用的。譬如，当我应用`succ 0`的时候，能否理想的获得`1`呢？
```
succ 0
= {将succ lambda化}
(\n f x -> f (n f x)) 0
= {将0替换n}
(\0 f x -> f (0 f x))
= {已经替换完成的变量消去}
\f x -> f (0 f x)
= {将0 lambda化}
\f x -> f ((\s z -> z) f x)
= {进一步替换}
\f x -> f x
```

有人可能会发现，将0 lambda化的时候，是`\s z -> z`而不是`\f x -> x`其实都一样，lambda演算只关心逻辑，不关心符号具体是什么，这样替换只是为了防止读者看花眼。

抬头一看，`1`的定义，不就是`\f x -> f x`吗？显然，succ很好的完成了计算一个数的后继数的功能。读者可以手动验算一下其他的函数，譬如pred、true、false

顺便一提
```
2 = \f x -> f (f x)
3 = \f x -> f (f (f x))
```

下一篇文章讲自然数。